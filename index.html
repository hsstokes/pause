<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Pause</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
            overscroll-behavior: none;
            touch-action: none;
        }
        
        canvas {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .info {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 20px);
            left: env(safe-area-inset-left, 20px);
            color: rgba(80, 80, 80, 0.7);
            font-family: 'Orator Std', monospace;
            font-size: 9px;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: opacity 0.3s ease;
            background: rgba(255, 255, 255, 0.3);
            padding: 5px 10px;
            border-radius: 3px;
        }
        
        .info:hover {
            opacity: 0.9;
        }
        
    </style>
</head>
<body>
    <div class="info">Toggle Â· Pause</div>
    
    <script>
        let pauseImage;
        let circles = [];
        let lines = [];
        let isAnimating = false;
        let percentLoaded = 0;
        let pauseText = "";
        let pauseTextTimer = 0;
        
        // Add these new sound-related variables
        let pauseSound;
        let soundPlaying = false;
        let soundEnabled = true;  // Whether sound is enabled globally

        function preload() {
            pauseImage = loadImage('pause.png');
            pauseSound = loadSound('pause_ambient.mp3');
        }

        function setup() {
            // Create canvas with responsive sizing
            let canvasWidth = min(windowWidth, 800);
            let aspectRatio = pauseImage.width / pauseImage.height;
            let canvasHeight = canvasWidth / aspectRatio;
            
            createCanvas(canvasWidth, canvasHeight);
            
            // Create interactive circles at key points
            circles.push(new InteractiveCircle(150 * canvasWidth/800, 150 * canvasHeight/(800/aspectRatio), 40 * canvasWidth/800, 'blue')); // Blue grid area
            circles.push(new InteractiveCircle(475 * canvasWidth/800, 200 * canvasHeight/(800/aspectRatio), 30 * canvasWidth/800, 'black')); // Center lines
            circles.push(new InteractiveCircle(350 * canvasWidth/800, 500 * canvasHeight/(800/aspectRatio), 25 * canvasWidth/800, 'tag')); // END tag area
            
            // Create interactive lines that follow the exact diagonal pattern in the image
            let lineStartX = 385 * canvasWidth/800;
            let lineStartY = 392 * canvasHeight/(800/aspectRatio);
            let lineEndX = 560 * canvasWidth/800;
            let lineEndY = 392 * canvasHeight/(800/aspectRatio);
            let lineSpacing = 8 * canvasHeight/(800/aspectRatio);
            
            for (let i = 0; i < 10; i++) {
                let y = lineStartY - i * lineSpacing;
                lines.push(new AnimatedLine(lineStartX, y, lineEndX, y));
            }
            
            // Loading animation
            let loadInterval = setInterval(() => {
                percentLoaded += 1;
                if (percentLoaded >= 100) {
                    clearInterval(loadInterval);
                    isAnimating = true;
                }
            }, 30);
        }

        function windowResized() {
            let canvasWidth = min(windowWidth, 800);
            let aspectRatio = pauseImage.width / pauseImage.height;
            let canvasHeight = canvasWidth / aspectRatio;
            
            resizeCanvas(canvasWidth, canvasHeight);
            
            // Update positions of interactive elements
            circles = [];
            lines = [];
            
            circles.push(new InteractiveCircle(150 * canvasWidth/800, 150 * canvasHeight/(800/aspectRatio), 40 * canvasWidth/800, 'blue'));
            circles.push(new InteractiveCircle(475 * canvasWidth/800, 200 * canvasHeight/(800/aspectRatio), 30 * canvasWidth/800, 'black'));
            circles.push(new InteractiveCircle(350 * canvasWidth/800, 500 * canvasHeight/(800/aspectRatio), 25 * canvasWidth/800, 'tag'));
            
            let lineStartX = 385 * canvasWidth/800;
            let lineStartY = 392 * canvasHeight/(800/aspectRatio);
            let lineEndX = 560 * canvasWidth/800;
            let lineEndY = 392 * canvasHeight/(800/aspectRatio);
            let lineSpacing = 8 * canvasHeight/(800/aspectRatio);
            
            for (let i = 0; i < 10; i++) {
                let y = lineStartY - i * lineSpacing;
                lines.push(new AnimatedLine(lineStartX, y, lineEndX, y));
            }
        }

        function draw() {
            // Display the background image
            image(pauseImage, 0, 0, width, height);
            
            // If still loading, show progress
            if (percentLoaded < 100) {
                drawLoadingIndicator();
                return;
            }
            
            // Draw and update interactive elements
            for (let circle of circles) {
                circle.update();
                circle.display();
            }
            
            for (let line of lines) {
                line.update();
                line.display();
            }
            
            // Add indicators based on animation state
            if (isAnimating) {
                // Subtle play indicator that fits with the % symbol area
                textSize(9 * width/800);
                textFont('Orator Std');
                textAlign(CENTER);
                fill(80, 80, 80, 110);
                text("P L A Y", width * 0.975, height * 0.43);
                
                // Add a subtle underline
                stroke(80, 80, 80, 60);
                strokeWeight(0.5);
                line(width * 0.95, height * 0.435, width * 0.995, height * 0.435);
              
                // Add a subtle progress indicator on the END tag
                noFill();
                stroke(120, 120, 120, 100);
                strokeWeight(0.5);
                let progressWidth = 30 * width/800;
                rect(width * 0.4375, height * 0.625 + 15 * height/800, progressWidth, 3);
                fill(120, 120, 120, 100);
                rect(width * 0.4375, height * 0.625 + 15 * height/800, progressWidth * (frameCount % 100)/100, 3);
            } else {
                // Typewriter effect for PAUSE
                textSize(9 * width/800);
                textFont('Orator Std');
                textAlign(CENTER);
                fill(80, 80, 80, 110);
                
                // Typewriter effect
                if (pauseTextTimer < 5) {
                    pauseTextTimer++;
                } else {
                    if (pauseText.length < 5) {
                        pauseText = "PAUSE".substring(0, pauseText.length + 1);
                        pauseTextTimer = 0;
                    }
                }
                text(pauseText, width * 0.975, height * 0.43);
            }

            // Animated ring around the purple circle
            let circleX = width * 0.75; 
            let circleY = height * 0.8; 
            let circleRadius = 30 * width/800;
            noFill();
            stroke(60, 30, 80, 70 + 30 * sin(frameCount * 0.05));
            strokeWeight(1);
            ellipse(circleX, circleY, circleRadius * 2 + 5 + 3 * sin(frameCount * 0.05));
            
            // Subtle grid animation in blue area
            if (isAnimating) {
                push();
                stroke(255, 255, 255, 20 + 10 * sin(frameCount * 0.02));
                strokeWeight(0.3);
                let gridSize = 15 * width/800;
                let gridX = width * 0.1875; // Blue grid area center
                let gridY = height * 0.1875;
                let gridWidth = 100 * width/800;
                let gridHeight = 100 * height/800;
                for (let x = gridX - gridWidth/2; x <= gridX + gridWidth/2; x += gridSize) {
                    line(x, gridY - gridHeight/2, x, gridY + gridHeight/2);
                }
                for (let y = gridY - gridHeight/2; y <= gridY + gridHeight/2; y += gridSize) {
                    line(gridX - gridWidth/2, y, gridX + gridWidth/2, y);
                }
            
                // Add the animated cross right here - it will be part of the same push/pop context
                // Animated cross that matches the design
                stroke(80, 170, 210, 90 + 40 * sin(frameCount * 0.03));
                strokeWeight(1);
                let crossX = width * 0.5; // Adjust position as needed
                let crossY = height * 0.5; // Adjust position as needed
                let crossSize = (10 + 2 * sin(frameCount * 0.04)) * width/800;
                line(crossX - crossSize, crossY, crossX + crossSize, crossY);
                line(crossX, crossY - crossSize, crossX, crossY + crossSize);
                
                pop();
                
                // Animated dots for the "END" tag
                for (let i = 0; i < 3; i++) {
                    let dotX = width * 0.4375 + i * 15 * width/800;
                    let dotY = height * 0.92;
                    let alpha = 80 + 70 * sin(frameCount * 0.05 + i * 0.5);
                    fill(100, 100, 100, alpha);
                    noStroke();
                    ellipse(dotX, dotY, 3 * width/800, 3 * width/800);
                }
                
                // Subtle movement of central line structure
                push();
                stroke(0, 0, 0, 60);
                strokeWeight(0.5);
                let lineCount = 6;
                let lineSpacing = 8 * height/800;
                let lineStartX = width * 0.875;
                let lineY = height * 0.5;
                let amplitude = 2 * width/800;
                
                for (let i = 0; i < lineCount; i++) {
                    let offset = amplitude * sin(frameCount * 0.03 + i * 0.2);
                    line(lineStartX, lineY + i * lineSpacing + offset, 
                         lineStartX + 80 * width/800, lineY + i * lineSpacing - offset);
                }
                pop();
            }
            
            // Sound control button
            push();
            let buttonX = width - 40 * width/800;
            let buttonY = height - 40 * height/800;
            let buttonSize = 30 * width/800;

            // Button background
            noStroke();
            fill(0, 0, 0, 30);
            rect(buttonX, buttonY, buttonSize, buttonSize, 5);

            // Sound icon
            if (soundEnabled) {
                // Sound on icon
                fill(60, 60, 60, 140);
                noStroke();
                // Speaker base
                rect(buttonX + 10 * width/800, buttonY + 12 * height/800, 4 * width/800, 6 * height/800);
                // Speaker cone
                beginShape();
                vertex(buttonX + 10 * width/800, buttonY + 12 * height/800);
                vertex(buttonX + 16 * width/800, buttonY + 8 * height/800);
                vertex(buttonX + 16 * width/800, buttonY + 22 * height/800);
                vertex(buttonX + 10 * width/800, buttonY + 18 * height/800);
                endShape(CLOSE);
                // Sound waves
                noFill();
                stroke(60, 60, 60, 140);
                strokeWeight(1);
                arc(buttonX + 18 * width/800, buttonY + 15 * height/800, 6 * width/800, 8 * height/800, -PI/3, PI/3);
                arc(buttonX + 18 * width/800, buttonY + 15 * height/800, 10 * width/800, 14 * height/800, -PI/3, PI/3);
            } else {
                // Sound off icon
                fill(60, 60, 60, 140);
                noStroke();
                // Speaker base
                rect(buttonX + 10 * width/800, buttonY + 12 * height/800, 4 * width/800, 6 * height/800);
                // Speaker cone
                beginShape();
                vertex(buttonX + 10 * width/800, buttonY + 12 * height/800);
                vertex(buttonX + 16 * width/800, buttonY + 8 * height/800);
                vertex(buttonX + 16 * width/800, buttonY + 22 * height/800);
                vertex(buttonX + 10 * width/800, buttonY + 18 * height/800);
                endShape(CLOSE);
                // X over the speaker
                stroke(60, 60, 60, 140);
                strokeWeight(1.5);
                line(buttonX + 19 * width/800, buttonY + 10 * height/800, buttonX + 24 * width/800, buttonY + 20 * height/800);
                line(buttonX + 24 * width/800, buttonY + 10 * height/800, buttonX + 19 * width/800, buttonY + 20 * height/800);
            }
            pop();
        }

        function touchStarted() {
            // Check if any circle was touched
            for (let circle of circles) {
                if (circle.contains(touchX || mouseX, touchY || mouseY)) {
                    circle.clicked();
                    toggleAnimation();
                    return false; // Prevent default
                }
            }
            
            // Check if sound button was touched
            let buttonX = width - 40 * width/800;
            let buttonY = height - 40 * height/800;
            let buttonSize = 30 * width/800;
            
            if ((touchX || mouseX) > buttonX && (touchX || mouseX) < buttonX + buttonSize && 
                (touchY || mouseY) > buttonY && (touchY || mouseY) < buttonY + buttonSize) {
                
                soundEnabled = !soundEnabled;
                
                if (!soundEnabled && soundPlaying) {
                    pauseSound.setVolume(0, 1);
                    setTimeout(() => {
                        pauseSound.stop();
                        soundPlaying = false;
                    }, 1000);
                } else if (soundEnabled && isAnimating && !soundPlaying) {
                    pauseSound.loop();
                    pauseSound.setVolume(0);
                    pauseSound.setVolume(1, 1);
                    soundPlaying = true;
                }
                return false; // Prevent default
            }
            
            return false; // Prevent default behavior like scrolling
        }

        // Keep mousePressed for desktop compatibility
        function mousePressed() {
            touchStarted();
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            // Toggle animation state for all elements
            for (let line of lines) {
                line.isAnimating = isAnimating;
            }
            
            // Reset typewriter effect when starting animation
            if (isAnimating) {
                pauseText = "";

                // Start playing sound if it's enabled
                if (soundEnabled && !soundPlaying) {
                    pauseSound.loop();
                    pauseSound.setVolume(0);
                    pauseSound.setVolume(1, 1.5); // Fade in over 1.5 seconds
                    soundPlaying = true;
                }
            } else {
                // Fade out sound when pausing
                if (soundPlaying && soundEnabled) {
                    pauseSound.setVolume(0, 1.5); // Fade out over 1.5 seconds
                    setTimeout(() => {
                        pauseSound.stop();
                        soundPlaying = false;
                    }, 1500);
                }
            }
        }

        function drawLoadingIndicator() {
            // Semi-transparent overlay
            fill(255, 255, 255, 150);
            noStroke();
            rect(0, 0, width, height);
            
            // Loading bar
            stroke(100);
            noFill();
            rect(width/2 - 100 * width/800, height/2 - 10 * height/800, 200 * width/800, 20 * height/800);
            
            // Loading progress
            fill(80, 150, 200);
            noStroke();
            rect(width/2 - 100 * width/800, height/2 - 10 * height/800, (percentLoaded * 2) * width/800, 20 * height/800);
            
            // Text
            fill(50);
            textSize(16 * width/800);
            textAlign(CENTER);
            text("Loading... " + percentLoaded + "%", width/2, height/2 + 30 * height/800);
        }

        // Interactive circle class
        class InteractiveCircle {
            constructor(x, y, radius, colorScheme) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.originalRadius = radius;
                this.hover = false;
                this.colorScheme = colorScheme;
            }
            
            update() {
                // Check if mouse is over the circle
                this.hover = dist(touchX || mouseX, touchY || mouseY, this.x, this.y) < this.radius;
                
                // Grow/shrink effect on hover
                if (this.hover) {
                    this.radius = lerp(this.radius, this.originalRadius * 1.2, 0.1);
                } else {
                    this.radius = lerp(this.radius, this.originalRadius, 0.1);
                }
            }
            
            display() {
                noStroke();
                
                // Apply different styles based on the area of the image
                if (this.colorScheme === 'blue') {
                  // Blue grid area style
                  fill(80, 170, 210, this.hover ? 180 : 120);
                  ellipse(this.x, this.y, this.radius * 2);
                  if (this.hover) {
                    stroke(255);
                    strokeWeight(1);
                    noFill();
                    ellipse(this.x, this.y, this.radius * 2.2);
                  }
                 } 
                 else if (this.colorScheme === 'tag') {
                   // END tag area style
                   noFill();
                   stroke(100, 100, 100, this.hover ? 180 : 120);
                   strokeWeight(1.5);
                   rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2, 3);
                   if (this.hover) {
                      fill(220, 220, 220, 120);
                      rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2, 3);
                   }
                  }
                  else {
                    // Center lines area style - make a small line segment instead of a circle
                    stroke(0, 0, 0, this.hover ? 180 : 120);
                    strokeWeight(2);
                    line(this.x - this.radius, this.y, this.x + this.radius, this.y);
      
                     if (this.hover) {
                        noFill();
                        strokeWeight(1);
                        ellipse(this.x, this.y, this.radius * 2);
                     }
                    }
    
                    // Clearer play/pause indication that fits the aesthetic
                    if (this.hover) {
                      if (isAnimating) {
                        // Pause symbol
                        fill(40, 40, 40, 180);
                        noStroke();
                        rect(this.x - this.radius/3, this.y - this.radius/2, this.radius/4, this.radius);
                        rect(this.x + this.radius/8, this.y - this.radius/2, this.radius/4, this.radius);
                    } else {
                        // Play symbol
                        fill(40, 40, 40, 180);
                        noStroke();
                        beginShape();
                        vertex(this.x - this.radius/3, this.y - this.radius/2);
                        vertex(this.x + this.radius/2, this.y);
                        vertex(this.x - this.radius/3, this.y + this.radius/2);
                        endShape(CLOSE);
                    }
                }
            }
            
            contains(px, py) {
                return dist(px, py, this.x, this.y) < this.radius;
            }
            
            clicked() {
                // Animation when clicked
                this.radius = this.originalRadius * 1.5;
            }
        }

        // Animated line class
        class AnimatedLine {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.progress = random(0, 1); // Start at random positions
                this.isAnimating = false;
                this.speed = random(0.005, 0.02);
                this.dotSize = random(3, 6) * width/800; // Varied dot sizes
            }
            
            update() {
                if (this.isAnimating) {
                    this.progress += this.speed;
                    if (this.progress > 1) {
                        this.progress = 0;
                    }
                }
            }
            
            display() {
                stroke(0, 0, 0, 100);
                strokeWeight(0.8);

                // Draw the line
                line(this.x1, this.y1, this.x2, this.y2);
                
                if (this.isAnimating) {
                    // Animate a dot moving along the line
                    let px = lerp(this.x1, this.x2, this.progress);
                    let py = lerp(this.y1, this.y2, this.progress);
                    
                    // More elegant dots
                    fill(0, 0, 0, 180);
                    noStroke();
                    ellipse(px, py, this.dotSize, this.dotSize);
                }
            }
        }

        // Try to handle autoplay restrictions on mobile
        function touchEnded() {
            // Some browsers require user interaction to play audio
            if (soundEnabled && isAnimating && !soundPlaying) {
                // Try to start sound on first interaction
                pauseSound.loop();
                pauseSound.setVolume(0);
                pauseSound.setVolume(1, 1.5);
                soundPlaying = true;
            }
            return false;
        }

        // Initialize audio on first touch for iOS
        document.addEventListener('touchstart', function() {
            // Create and play a silent sound to unlock the audio context
            if (pauseSound && !pauseSound.isPlaying() && soundEnabled && isAnimating) {
                pauseSound.setVolume(0);
                pauseSound.play();
                pauseSound.stop();
            }
        }, {once: true});
    </script>
</body>
</html>
