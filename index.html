<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Pause</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info">Click on the circles to toggle animation</div>
    
    <script>
        let pauseImage;
        let circles = [];
        let lines = [];
        let isAnimating = false;
        let percentLoaded = 0;
        let pauseText = "";
        let pauseTextTimer = 0;
        
        // Add these new sound-related variables
        let pauseSound;
        let soundPlaying = false;
        let soundEnabled = true;  // Whether sound is enabled globally

        function preload() {
            pauseImage = loadImage('pause.png');
            pauseSound = loadSound('pause_ambient.mp3');
        }

        function setup() {
             // Create canvas with proper aspect ratio
            let aspectRatio = pauseImage.width / pauseImage.height;
  
            // Set a fixed width and calculate height based on aspect ratio
            let canvasWidth = 800;
            let canvasHeight = canvasWidth / aspectRatio;
            createCanvas(canvasWidth, canvasHeight);
            
            // Create interactive circles at key points
            circles.push(new InteractiveCircle(150, 150, 40, 'blue')); // Blue grid area
            circles.push(new InteractiveCircle(475, 200, 30, 'black')); // Center lines
            circles.push(new InteractiveCircle(350, 500, 25, 'tag')); // END tag area
            
            // Create interactive lines that follow the exact diagonal pattern in the image
            let lineStartX = 385;
            let lineStartY = 392;
            let lineEndX = 560;
            let lineEndY = 392;
            let lineSpacing = 8;
            
            for (let i = 0; i < 10; i++) {
                let y = lineStartY - i * lineSpacing;
                lines.push(new AnimatedLine(lineStartX, y, lineEndX, y));
            }
            
            // Loading animation
            let loadInterval = setInterval(() => {
                percentLoaded += 1;
                if (percentLoaded >= 100) {
                    clearInterval(loadInterval);
                    isAnimating = true;
                }
            }, 30);
        }

        function draw() {
            // Display the background image
            image(pauseImage, 0, 0, width, height);
            
            // If still loading, show progress
            if (percentLoaded < 100) {
                drawLoadingIndicator();
                return;
            }
            
            // Draw and update interactive elements
            for (let circle of circles) {
                circle.update();
                circle.display();
            }
            
            for (let line of lines) {
                line.update();
                line.display();
            }
            
            // Add indicators based on animation state
            if (isAnimating) {
                // Subtle play indicator that fits with the % symbol area
                textSize(9);
                textFont('Orator Std');
                textAlign(CENTER);
                fill(80, 80, 80, 110);
                text("P L A Y", 780, 344);
                
                // Add a subtle underline
                stroke(80, 80, 80, 60);
                strokeWeight(0.5);
                line(765, 347, 795, 347);
              
                // Add a subtle progress indicator on the END tag
                noFill();
                stroke(120, 120, 120, 100);
                strokeWeight(0.5);
                let progressWidth = 30;
                rect(350, 500 + 15, progressWidth, 3);
                fill(120, 120, 120, 100);
                rect(350, 500 + 15, progressWidth * (frameCount % 100)/100, 3);
            } else {
                // Typewriter effect for PAUSE
                textSize(9);
                textFont('Orator Std');
                textAlign(CENTER);
                fill(80, 80, 80, 110);
                
                // Typewriter effect
                if (pauseTextTimer < 5) {
                    pauseTextTimer++;
                } else {
                    if (pauseText.length < 5) {
                        pauseText = "PAUSE".substring(0, pauseText.length + 1);
                        pauseTextTimer = 0;
                    }
                }
                text(pauseText, 780, 344);
            }

            // Animated ring around the purple circle
            let circleX = 600; 
            let circleY = 640; 
            let circleRadius = 30;
            noFill();
            stroke(60, 30, 80, 70 + 30 * sin(frameCount * 0.05));
            strokeWeight(1);
            ellipse(circleX, circleY, circleRadius * 2 + 5 + 3 * sin(frameCount * 0.05));
            
            // Subtle grid animation in blue area
            if (isAnimating) {
                push();
                stroke(255, 255, 255, 20 + 10 * sin(frameCount * 0.02));
                strokeWeight(0.3);
                let gridSize = 15;
                let gridX = 150; // Blue grid area center
                let gridY = 150;
                let gridWidth = 100;
                let gridHeight = 100;
                for (let x = gridX - gridWidth/2; x <= gridX + gridWidth/2; x += gridSize) {
                    line(x, gridY - gridHeight/2, x, gridY + gridHeight/2);
                }
                for (let y = gridY - gridHeight/2; y <= gridY + gridHeight/2; y += gridSize) {
                    line(gridX - gridWidth/2, y, gridX + gridWidth/2, y);
                }
            
                // Add the animated cross right here - it will be part of the same push/pop context
                // Animated cross that matches the design
                stroke(80, 170, 210, 90 + 40 * sin(frameCount * 0.03));
                strokeWeight(1);
                let crossX = 400; // Adjust position as needed
                let crossY = 400; // Adjust position as needed
                let crossSize = 10 + 2 * sin(frameCount * 0.04);
                line(crossX - crossSize, crossY, crossX + crossSize, crossY);
                line(crossX, crossY - crossSize, crossX, crossY + crossSize);
                
                pop();
                
                // Animated dots for the "END" tag
                for (let i = 0; i < 3; i++) {
                    let dotX = 350 + i * 15;
                    let dotY = 735;
                    let alpha = 80 + 70 * sin(frameCount * 0.05 + i * 0.5);
                    fill(100, 100, 100, alpha);
                    noStroke();
                    ellipse(dotX, dotY, 3, 3);
                }
                
                // Subtle movement of central line structure
                push();
                stroke(0, 0, 0, 60);
                strokeWeight(0.5);
                let lineCount = 6;
                let lineSpacing = 8;
                let lineStartX = 700;
                let lineY = 400;
                let amplitude = 2;
                
                for (let i = 0; i < lineCount; i++) {
                    let offset = amplitude * sin(frameCount * 0.03 + i * 0.2);
                    line(lineStartX, lineY + i * lineSpacing + offset, 
                         lineStartX + 80, lineY + i * lineSpacing - offset);
                }
                pop();
            }
            
            // Sound control button
            push();
            let buttonX = width - 40;
            let buttonY = height - 40;
            let buttonSize = 30;

            // Button background
            noStroke();
            fill(0, 0, 0, 30);
            rect(buttonX, buttonY, buttonSize, buttonSize, 5);

            // Sound icon
            if (soundEnabled) {
                // Sound on icon
                fill(60, 60, 60, 140);
                noStroke();
                // Speaker base
                rect(buttonX + 10, buttonY + 12, 4, 6);
                // Speaker cone
                beginShape();
                vertex(buttonX + 10, buttonY + 12);
                vertex(buttonX + 16, buttonY + 8);
                vertex(buttonX + 16, buttonY + 22);
                vertex(buttonX + 10, buttonY + 18);
                endShape(CLOSE);
                // Sound waves
                noFill();
                stroke(60, 60, 60, 140);
                strokeWeight(1);
                arc(buttonX + 18, buttonY + 15, 6, 8, -PI/3, PI/3);
                arc(buttonX + 18, buttonY + 15, 10, 14, -PI/3, PI/3);
            } else {
                // Sound off icon
                fill(60, 60, 60, 140);
                noStroke();
                // Speaker base
                rect(buttonX + 10, buttonY + 12, 4, 6);
                // Speaker cone
                beginShape();
                vertex(buttonX + 10, buttonY + 12);
                vertex(buttonX + 16, buttonY + 8);
                vertex(buttonX + 16, buttonY + 22);
                vertex(buttonX + 10, buttonY + 18);
                endShape(CLOSE);
                // X over the speaker
                stroke(60, 60, 60, 140);
                strokeWeight(1.5);
                line(buttonX + 19, buttonY + 10, buttonX + 24, buttonY + 20);
                line(buttonX + 24, buttonY + 10, buttonX + 19, buttonY + 20);
            }
            pop();
        }

        function mousePressed() {
            // Check if any circle was clicked
            for (let circle of circles) {
                if (circle.contains(mouseX, mouseY)) {
                    circle.clicked();
                    toggleAnimation();
                    return;
                }
            }
            
            // Check if sound button was clicked
            let buttonX = width - 40;
            let buttonY = height - 40;
            let buttonSize = 30;
            
            if (mouseX > buttonX && mouseX < buttonX + buttonSize && 
                mouseY > buttonY && mouseY < buttonY + buttonSize) {
                
                soundEnabled = !soundEnabled;
                
                if (!soundEnabled && soundPlaying) {
                    // Fade out and stop sound if it's playing
                    pauseSound.setVolume(0, 1);
                    setTimeout(() => {
                        pauseSound.stop();
                        soundPlaying = false;
                    }, 1000);
                } else if (soundEnabled && isAnimating && !soundPlaying) {
                    // Start sound if animation is active
                    pauseSound.loop();
                    pauseSound.setVolume(0);
                    pauseSound.setVolume(1, 1);
                    soundPlaying = true;
                }
                return;
            }
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            // Toggle animation state for all elements
            for (let line of lines) {
                line.isAnimating = isAnimating;
            }
            
            // Reset typewriter effect when starting animation
            if (isAnimating) {
                pauseText = "";

                // Start playing sound if it's enabled
                if (soundEnabled && !soundPlaying) {
                    pauseSound.loop();
                    pauseSound.setVolume(0);
                    pauseSound.setVolume(1, 1.5); // Fade in over 1.5 seconds
                    soundPlaying = true;
                }
            } else {
                // Fade out sound when pausing
                if (soundPlaying && soundEnabled) {
                    pauseSound.setVolume(0, 1.5); // Fade out over 1.5 seconds
                    setTimeout(() => {
                        pauseSound.stop();
                        soundPlaying = false;
                    }, 1500);
                }
            }
        }

        function drawLoadingIndicator() {
            // Semi-transparent overlay
            fill(255, 255, 255, 150);
            noStroke();
            rect(0, 0, width, height);
            
            // Loading bar
            stroke(100);
            noFill();
            rect(width/2 - 100, height/2 - 10, 200, 20);
            
            // Loading progress
            fill(80, 150, 200);
            noStroke();
            rect(width/2 - 100, height/2 - 10, percentLoaded * 2, 20);
            
            // Text
            fill(50);
            textSize(16);
            textAlign(CENTER);
            text("Loading... " + percentLoaded + "%", width/2, height/2 + 30);
        }

        // Interactive circle class
        class InteractiveCircle {
            constructor(x, y, radius, colorScheme) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.originalRadius = radius;
                this.hover = false;
                this.colorScheme = colorScheme;
            }
            
            update() {
                // Check if mouse is over the circle
                this.hover = dist(mouseX, mouseY, this.x, this.y) < this.radius;
                
                // Grow/shrink effect on hover
                if (this.hover) {
                    this.radius = lerp(this.radius, this.originalRadius * 1.2, 0.1);
                } else {
                    this.radius = lerp(this.radius, this.originalRadius, 0.1);
                }
            }
            
            display() {
                noStroke();
                
                // Apply different styles based on the area of the image
                if (this.colorScheme === 'blue') {
                  // Blue grid area style
                  fill(80, 170, 210, this.hover ? 180 : 120);
                  ellipse(this.x, this.y, this.radius * 2);
                  if (this.hover) {
                    stroke(255);
                    strokeWeight(1);
                    noFill();
                    ellipse(this.x, this.y, this.radius * 2.2);
                  }
                 } 
                 else if (this.colorScheme === 'tag') {
                   // END tag area style
                   noFill();
                   stroke(100, 100, 100, this.hover ? 180 : 120);
                   strokeWeight(1.5);
                   rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2, 3);
                   if (this.hover) {
                      fill(220, 220, 220, 120);
                      rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2, 3);
                   }
                  }
                  else {
                    // Center lines area style - make a small line segment instead of a circle
                    stroke(0, 0, 0, this.hover ? 180 : 120);
                    strokeWeight(2);
                    line(this.x - this.radius, this.y, this.x + this.radius, this.y);
      
                     if (this.hover) {
                        noFill();
                        strokeWeight(1);
                        ellipse(this.x, this.y, this.radius * 2);
                     }
                    }
    
                    // Clearer play/pause indication that fits the aesthetic
                    if (this.hover) {
                      if (isAnimating) {
                        // Pause symbol
                        fill(40, 40, 40, 180);
                        noStroke();
                        rect(this.x - this.radius/3, this.y - this.radius/2, this.radius/4, this.radius);
                        rect(this.x + this.radius/8, this.y - this.radius/2, this.radius/4, this.radius);
                    } else {
                        // Play symbol
                        fill(40, 40, 40, 180);
                        noStroke();
                        beginShape();
                        vertex(this.x - this.radius/3, this.y - this.radius/2);
                        vertex(this.x + this.radius/2, this.y);
                        vertex(this.x - this.radius/3, this.y + this.radius/2);
                        endShape(CLOSE);
                    }
                }
            }
            
            contains(px, py) {
                return dist(px, py, this.x, this.y) < this.radius;
            }
            
            clicked() {
                // Animation when clicked
                this.radius = this.originalRadius * 1.5;
            }
        }

        // Animated line class
        class AnimatedLine {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.progress = random(0, 1); // Start at random positions
                this.isAnimating = false;
                this.speed = random(0.005, 0.02);
                this.dotSize = random(3, 6); // Varied dot sizes
            }
            
            update() {
                if (this.isAnimating) {
                    this.progress += this.speed;
                    if (this.progress > 1) {
                        this.progress = 0;
                    }
                }
            }
            
            display() {
                stroke(0, 0, 0, 100);
                strokeWeight(0.8);

                // Draw the line
                line(this.x1, this.y1, this.x2, this.y2);
                
                if (this.isAnimating) {
                    // Animate a dot moving along the line
                    let px = lerp(this.x1, this.x2, this.progress);
                    let py = lerp(this.y1, this.y2, this.progress);
                    
                    // More elegant dots
                    fill(0, 0, 0, 180);
                    noStroke();
                    ellipse(px, py, this.dotSize, this.dotSize);
                }
            }
        }
    </script>
</body>
</html>
