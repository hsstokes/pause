<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Pause</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        canvas {
            max-width: 100%;
            max-height: 100vh;
            object-fit: contain;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(80, 80, 80, 0.7);
            font-family: 'Orator Std', monospace;
            font-size: 9px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div class="info">Toggle Â· Pause</div>
    
    <script>
        let pauseImage;
        let circles = [];
        let lines = [];
        let isAnimating = false;
        let percentLoaded = 0;
        let pauseText = "";
        let pauseTextTimer = 0;
        
        // Sound-related variables
        let pauseSound;
        let soundPlaying = false;
        let soundEnabled = true;
        
        // Canvas sizing variables
        let canvasWidth, canvasHeight;
        let scaleFactor = 1;

        function preload() {
            pauseImage = loadImage('pause.png');
            pauseSound = loadSound('pause_ambient.mp3');
        }

        function setup() {
            // Create canvas that fits the screen while maintaining aspect ratio
            let aspectRatio = pauseImage.width / pauseImage.height;
            
            if (windowWidth / windowHeight > aspectRatio) {
                // Screen is wider than image aspect ratio
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                // Screen is taller than image aspect ratio
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            
            createCanvas(canvasWidth, canvasHeight);
            
            // Calculate scale factor based on our reference size of 800px width
            scaleFactor = canvasWidth / 800;
            
            // Create interactive circles at key points, scaled to match canvas size
            circles.push(new InteractiveCircle(150 * scaleFactor, 150 * scaleFactor, 40 * scaleFactor, 'blue')); // Blue grid area
            circles.push(new InteractiveCircle(475 * scaleFactor, 200 * scaleFactor, 30 * scaleFactor, 'black')); // Center lines
            circles.push(new InteractiveCircle(350 * scaleFactor, 500 * scaleFactor, 25 * scaleFactor, 'tag')); // END tag area
            
            // Create interactive lines that follow the exact diagonal pattern in the image
            let lineStartX = 385 * scaleFactor;
            let lineStartY = 392 * scaleFactor;
            let lineEndX = 560 * scaleFactor;
            let lineEndY = 392 * scaleFactor;
            let lineSpacing = 8 * scaleFactor;
            
            for (let i = 0; i < 10; i++) {
                let y = lineStartY - i * lineSpacing;
                lines.push(new AnimatedLine(lineStartX, y, lineEndX, y));
            }
            
            // Loading animation
            let loadInterval = setInterval(() => {
                percentLoaded += 1;
                if (percentLoaded >= 100) {
                    clearInterval(loadInterval);
                    isAnimating = true;
                    
                    // Set all lines to animate
                    for (let line of lines) {
                        line.isAnimating = true;
                    }
                }
            }, 30);
            
            console.log("Canvas size:", canvasWidth, "x", canvasHeight, "Scale factor:", scaleFactor);
        }

        function windowResized() {
            // Recalculate canvas size on window resize
            let aspectRatio = pauseImage.width / pauseImage.height;
            
            if (windowWidth / windowHeight > aspectRatio) {
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            
            resizeCanvas(canvasWidth, canvasHeight);
            
            // Recalculate scale factor
            scaleFactor = canvasWidth / 800;
            
            // Recreate all interactive elements with new scale
            circles = [];
            lines = [];
            
            circles.push(new InteractiveCircle(150 * scaleFactor, 150 * scaleFactor, 40 * scaleFactor, 'blue'));
            circles.push(new InteractiveCircle(475 * scaleFactor, 200 * scaleFactor, 30 * scaleFactor, 'black'));
            circles.push(new InteractiveCircle(350 * scaleFactor, 500 * scaleFactor, 25 * scaleFactor, 'tag'));
            
            let lineStartX = 385 * scaleFactor;
            let lineStartY = 392 * scaleFactor;
            let lineEndX = 560 * scaleFactor;
            let lineEndY = 392 * scaleFactor;
            let lineSpacing = 8 * scaleFactor;
            
            for (let i = 0; i < 10; i++) {
                let y = lineStartY - i * lineSpacing;
                lines.push(new AnimatedLine(lineStartX, y, lineEndX, y));
                lines[i].isAnimating = isAnimating;
            }
            
            console.log("Resized canvas:", canvasWidth, "x", canvasHeight, "Scale factor:", scaleFactor);
        }

        function draw() {
            // Display the background image to fill the canvas
            image(pauseImage, 0, 0, canvasWidth, canvasHeight);
            
            // If still loading, show progress
            if (percentLoaded < 100) {
                drawLoadingIndicator();
                return;
            }
            
            // Draw and update interactive elements
            for (let circle of circles) {
                circle.update();
                circle.display();
            }
            
            for (let line of lines) {
                line.update();
                line.display();
            }
            
            // Add indicators based on animation state
            if (isAnimating) {
                // Subtle play indicator that fits with the % symbol area
                textSize(9 * scaleFactor);
                textFont('Orator Std');
                textAlign(CENTER);
                fill(80, 80, 80, 110);
                text("P L A Y", 780 * scaleFactor, 344 * scaleFactor);
                
                // Add a subtle underline
                stroke(80, 80, 80, 60);
                strokeWeight(0.5 * scaleFactor);
                line(765 * scaleFactor, 347 * scaleFactor, 795 * scaleFactor, 347 * scaleFactor);
              
                // Add a subtle progress indicator on the END tag
                noFill();
                stroke(120, 120, 120, 100);
                strokeWeight(0.5 * scaleFactor);
                let progressWidth = 30 * scaleFactor;
                rect(350 * scaleFactor, (500 + 15) * scaleFactor, progressWidth, 3 * scaleFactor);
                fill(120, 120, 120, 100);
                rect(350 * scaleFactor, (500 + 15) * scaleFactor, progressWidth * (frameCount % 100)/100, 3 * scaleFactor);
            } else {
                // Typewriter effect for PAUSE
                textSize(9 * scaleFactor);
                textFont('Orator Std');
                textAlign(CENTER);
                fill(80, 80, 80, 110);
                
                // Typewriter effect
                if (pauseTextTimer < 5) {
                    pauseTextTimer++;
                } else {
                    if (pauseText.length < 5) {
                        pauseText = "PAUSE".substring(0, pauseText.length + 1);
                        pauseTextTimer = 0;
                    }
                }
                text(pauseText, 780 * scaleFactor, 344 * scaleFactor);
            }

            // Animated ring around the purple circle
            let circleX = 600 * scaleFactor; 
            let circleY = 640 * scaleFactor; 
            let circleRadius = 30 * scaleFactor;
            noFill();
            stroke(60, 30, 80, 70 + 30 * sin(frameCount * 0.05));
            strokeWeight(1 * scaleFactor);
            ellipse(circleX, circleY, circleRadius * 2 + 5 * scaleFactor + 3 * scaleFactor * sin(frameCount * 0.05));
            
            // Subtle grid animation in blue area
            if (isAnimating) {
                push();
                stroke(255, 255, 255, 20 + 10 * sin(frameCount * 0.02));
                strokeWeight(0.3 * scaleFactor);
                let gridSize = 15 * scaleFactor;
                let gridX = 150 * scaleFactor; // Blue grid area center
                let gridY = 150 * scaleFactor;
                let gridWidth = 100 * scaleFactor;
                let gridHeight = 100 * scaleFactor;
                for (let x = gridX - gridWidth/2; x <= gridX + gridWidth/2; x += gridSize) {
                    line(x, gridY - gridHeight/2, x, gridY + gridHeight/2);
                }
                for (let y = gridY - gridHeight/2; y <= gridY + gridHeight/2; y += gridSize) {
                    line(gridX - gridWidth/2, y, gridX + gridWidth/2, y);
                }
            
                // Animated cross that matches the design
                stroke(80, 170, 210, 90 + 40 * sin(frameCount * 0.03));
                strokeWeight(1 * scaleFactor);
                let crossX = 400 * scaleFactor; 
                let crossY = 400 * scaleFactor; 
                let crossSize = (10 + 2 * sin(frameCount * 0.04)) * scaleFactor;
                line(crossX - crossSize, crossY, crossX + crossSize, crossY);
                line(crossX, crossY - crossSize, crossX, crossY + crossSize);
                
                pop();
                
                // Animated dots for the "END" tag
                for (let i = 0; i < 3; i++) {
                    let dotX = 350 * scaleFactor + i * 15 * scaleFactor;
                    let dotY = 735 * scaleFactor;
                    let alpha = 80 + 70 * sin(frameCount * 0.05 + i * 0.5);
                    fill(100, 100, 100, alpha);
                    noStroke();
                    ellipse(dotX, dotY, 3 * scaleFactor, 3 * scaleFactor);
                }
                
                // Subtle movement of central line structure
                push();
                stroke(0, 0, 0, 60);
                strokeWeight(0.5 * scaleFactor);
                let lineCount = 6;
                let lineSpacing = 8 * scaleFactor;
                let lineStartX = 700 * scaleFactor;
                let lineY = 400 * scaleFactor;
                let amplitude = 2 * scaleFactor;
                
                for (let i = 0; i < lineCount; i++) {
                    let offset = amplitude * sin(frameCount * 0.03 + i * 0.2);
                    line(lineStartX, lineY + i * lineSpacing + offset, 
                         lineStartX + 80 * scaleFactor, lineY + i * lineSpacing - offset);
                }
                pop();
            }
            
            // Sound control button
            push();
            let buttonX = width - 40 * scaleFactor;
            let buttonY = height - 40 * scaleFactor;
            let buttonSize = 30 * scaleFactor;

            // Button background
            noStroke();
            fill(0, 0, 0, 30);
            rect(buttonX, buttonY, buttonSize, buttonSize, 5 * scaleFactor);

            // Sound icon
            if (soundEnabled) {
                // Sound on icon
                fill(60, 60, 60, 140);
                noStroke();
                // Speaker base
                rect(buttonX + 10 * scaleFactor, buttonY + 12 * scaleFactor, 4 * scaleFactor, 6 * scaleFactor);
                // Speaker cone
                beginShape();
                vertex(buttonX + 10 * scaleFactor, buttonY + 12 * scaleFactor);
                vertex(buttonX + 16 * scaleFactor, buttonY + 8 * scaleFactor);
                vertex(buttonX + 16 * scaleFactor, buttonY + 22 * scaleFactor);
                vertex(buttonX + 10 * scaleFactor, buttonY + 18 * scaleFactor);
                endShape(CLOSE);
                // Sound waves
                noFill();
                stroke(60, 60, 60, 140);
                strokeWeight(1 * scaleFactor);
                arc(buttonX + 18 * scaleFactor, buttonY + 15 * scaleFactor, 6 * scaleFactor, 8 * scaleFactor, -PI/3, PI/3);
                arc(buttonX + 18 * scaleFactor, buttonY + 15 * scaleFactor, 10 * scaleFactor, 14 * scaleFactor, -PI/3, PI/3);
            } else {
                // Sound off icon
                fill(60, 60, 60, 140);
                noStroke();
                // Speaker base
                rect(buttonX + 10 * scaleFactor, buttonY + 12 * scaleFactor, 4 * scaleFactor, 6 * scaleFactor);
                // Speaker cone
                beginShape();
                vertex(buttonX + 10 * scaleFactor, buttonY + 12 * scaleFactor);
                vertex(buttonX + 16 * scaleFactor, buttonY + 8 * scaleFactor);
                vertex(buttonX + 16 * scaleFactor, buttonY + 22 * scaleFactor);
                vertex(buttonX + 10 * scaleFactor, buttonY + 18 * scaleFactor);
                endShape(CLOSE);
                // X over the speaker
                stroke(60, 60, 60, 140);
                strokeWeight(1.5 * scaleFactor);
                line(buttonX + 19 * scaleFactor, buttonY + 10 * scaleFactor, buttonX + 24 * scaleFactor, buttonY + 20 * scaleFactor);
                line(buttonX + 24 * scaleFactor, buttonY + 10 * scaleFactor, buttonX + 19 * scaleFactor, buttonY + 20 * scaleFactor);
            }
            pop();
        }

        function mousePressed() {
            console.log("Mouse pressed at:", mouseX, mouseY);
            
            // Check if any circle was clicked
            for (let circle of circles) {
                if (circle.contains(mouseX, mouseY)) {
                    console.log("Circle clicked!");
                    circle.clicked();
                    toggleAnimation();
                    return false;
                }
            }
            
            // Check if sound button was clicked
            let buttonX = width - 40 * scaleFactor;
            let buttonY = height - 40 * scaleFactor;
            let buttonSize = 30 * scaleFactor;
            
            if (mouseX > buttonX && mouseX < buttonX + buttonSize && 
                mouseY > buttonY && mouseY < buttonY + buttonSize) {
                
                console.log("Sound button clicked!");
                soundEnabled = !soundEnabled;
                
                if (!soundEnabled && soundPlaying) {
                    // Fade out and stop sound if it's playing
                    pauseSound.setVolume(0, 1);
                    setTimeout(() => {
                        pauseSound.stop();
                        soundPlaying = false;
                    }, 1000);
                } else if (soundEnabled && isAnimating && !soundPlaying) {
                    // Start sound if animation is active
                    pauseSound.loop();
                    pauseSound.setVolume(0);
                    pauseSound.setVolume(1, 1);
                    soundPlaying = true;
                }
                return false;
            }
            
            return false;
        }

        // Support touch events
        function touchStarted() {
            return mousePressed();
        }

        function toggleAnimation() {
            console.log("Toggling animation from:", isAnimating, "to:", !isAnimating);
            isAnimating = !isAnimating;
            
            // Toggle animation state for all elements
            for (let line of lines) {
                line.isAnimating = isAnimating;
            }
            
            // Reset typewriter effect when starting animation
            if (isAnimating) {
                pauseText = "";

                // Start playing sound if it's enabled
                if (soundEnabled && !soundPlaying) {
                    try {
                        pauseSound.loop();
                        pauseSound.setVolume(0);
                        pauseSound.setVolume(1, 1.5); // Fade in over 1.5 seconds
                        soundPlaying = true;
                    } catch(e) {
                        console.log("Audio error:", e);
                    }
                }
            } else {
                // Fade out sound when pausing
                if (soundPlaying && soundEnabled) {
                    pauseSound.setVolume(0, 1.5); // Fade out over 1.5 seconds
                    setTimeout(() => {
                        pauseSound.stop();
                        soundPlaying = false;
                    }, 1500);
                }
            }
        }

        function drawLoadingIndicator() {
            // Semi-transparent overlay
            fill(255, 255, 255, 150);
            noStroke();
            rect(0, 0, width, height);
            
            // Loading bar
            stroke(100);
            noFill();
            rect(width/2 - 100 * scaleFactor, height/2 - 10 * scaleFactor, 200 * scaleFactor, 20 * scaleFactor);
            
            // Loading progress
            fill(80, 150, 200);
            noStroke();
            rect(width/2 - 100 * scaleFactor, height/2 - 10 * scaleFactor, (percentLoaded * 2) * scaleFactor, 20 * scaleFactor);
            
            // Text
            fill(50);
            textSize(16 * scaleFactor);
            textAlign(CENTER);
            text("Loading... " + percentLoaded + "%", width/2, height/2 + 30 * scaleFactor);
        }

        // Interactive circle class
        class InteractiveCircle {
            constructor(x, y, radius, colorScheme) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.originalRadius = radius;
                this.hover = false;
                this.colorScheme = colorScheme;
            }
            
            update() {
                // Check if mouse is over the circle
                this.hover = dist(mouseX, mouseY, this.x, this.y) < this.radius;
                
                // Grow/shrink effect on hover
                if (this.hover) {
                    this.radius = lerp(this.radius, this.originalRadius * 1.2, 0.1);
                } else {
                    this.radius = lerp(this.radius, this.originalRadius, 0.1);
                }
            }
            
            display() {
                noStroke();
                
                // Apply different styles based on the area of the image
                if (this.colorScheme === 'blue') {
                  // Blue grid area style
                  fill(80, 170, 210, this.hover ? 180 : 120);
                  ellipse(this.x, this.y, this.radius * 2);
                  if (this.hover) {
                    stroke(255);
                    strokeWeight(1 * scaleFactor);
                    noFill();
                    ellipse(this.x, this.y, this.radius * 2.2);
                  }
                 } 
                 else if (this.colorScheme === 'tag') {
                   // END tag area style
                   noFill();
                   stroke(100, 100, 100, this.hover ? 180 : 120);
                   strokeWeight(1.5 * scaleFactor);
                   rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2, 3 * scaleFactor);
                   if (this.hover) {
                      fill(220, 220, 220, 120);
                      rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2, 3 * scaleFactor);
                   }
                  }
                  else {
                    // Center lines area style - make a small line segment instead of a circle
                    stroke(0, 0, 0, this.hover ? 180 : 120);
                    strokeWeight(2 * scaleFactor);
                    line(this.x - this.radius, this.y, this.x + this.radius, this.y);
      
                     if (this.hover) {
                        noFill();
                        strokeWeight(1 * scaleFactor);
                        ellipse(this.x, this.y, this.radius * 2);
                     }
                    }
    
                    // Clearer play/pause indication that fits the aesthetic
                    if (this.hover) {
                      if (isAnimating) {
                        // Pause symbol
                        fill(40, 40, 40, 180);
                        noStroke();
                        rect(this.x - this.radius/3, this.y - this.radius/2, this.radius/4, this.radius);
                        rect(this.x + this.radius/8, this.y - this.radius/2, this.radius/4, this.radius);
                    } else {
                        // Play symbol
                        fill(40, 40, 40, 180);
                        noStroke();
                        beginShape();
                        vertex(this.x - this.radius/3, this.y - this.radius/2);
                        vertex(this.x + this.radius/2, this.y);
                        vertex(this.x - this.radius/3, this.y + this.radius/2);
                        endShape(CLOSE);
                    }
                }
            }
            
            contains(px, py) {
                return dist(px, py, this.x, this.y) < this.radius;
            }
            
            clicked() {
                // Animation when clicked
                this.radius = this.originalRadius * 1.5;
            }
        }

        // Animated line class
        class AnimatedLine {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.progress = random(0, 1); // Start at random positions
                this.isAnimating = false;
                this.speed = random(0.005, 0.02);
                this.dotSize = random(3, 6) * scaleFactor; // Varied dot sizes
            }
            
            update() {
                if (this.isAnimating) {
                    this.progress += this.speed;
                    if (this.progress > 1) {
                        this.progress = 0;
                    }
                }
            }
            
            display() {
                stroke(0, 0, 0, 100);
                strokeWeight(0.8 * scaleFactor);

                // Draw the line
                line(this.x1, this.y1, this.x2, this.y2);
                
                if (this.isAnimating) {
                    // Animate a dot moving along the line
                    let px = lerp(this.x1, this.x2, this.progress);
                    let py = lerp(this.y1, this.y2, this.progress);
                    
                    // More elegant dots
                    fill(0, 0, 0, 180);
                    noStroke();
                    ellipse(px, py, this.dotSize, this.dotSize);
                }
            }
        }

        // For iOS/Safari, try to enable audio on first interaction
        document.addEventListener('touchstart', function() {
            if (pauseSound && soundEnabled && !soundPlaying && isAnimating) {
                // Try to start sound on first interaction for iOS
                try {
                    pauseSound.loop();
                    pauseSound.setVolume(0);
                    pauseSound.setVolume(1, 1.5);
                    soundPlaying = true;
                } catch(e) {
                    console.log("Couldn't autoplay audio:", e);
                }
            }
        }, {once: true});
    </script>
</body>
</html>
